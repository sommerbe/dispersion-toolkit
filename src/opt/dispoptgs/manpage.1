.\" Automatically generated by Pandoc 2.7.3
.\"
.TH "DISPOPTGS" "1" "November 30, 2020" "1.0.0" "Dispersion Toolkit Manuals"
.hy
.SH NAME
.PP
dispoptgs - a gradient ascent to reduce dispersion based on grow&shrink
strategy
.SH SYNOPSIS
.PP
\f[B]dispoptgs\f[R] [\f[B]--i\f[R] \f[I]FILE\f[R]] [\f[B]--o\f[R]
\f[I]FILE\f[R]] [\f[B]--iteration-limit\f[R]=\f[I]INTEGER\f[R]]
[\f[B]--tau\f[R]=\f[I]BINARY64\f[R]]
[\f[B]--stepsize\f[R]=\f[I]BINARY64\f[R]]
[\f[B]--delimiter\f[R]=\f[I]CHARACTER\f[R]] [\f[B]--no-pointset\f[R]]
[\f[B]--compute-iterations\f[R]] [\f[B]--pointset-sequence\f[R]]
[\f[B]--silent\f[R]]
.SH DESCRIPTION
.PP
Seeks to reduce dispersion of a point set by using gradient ascent on
local dispersion.
\f[I]Local dispersion\f[R] at a point p is the area of the greatest
empty box out of all empty boxes of the point set which contain p.
.PP
The axis aligned gradient of local dispersion at each point p of the
point set equals the vector with which p is moved iteratively during the
ascent.
This vector is scaled with a step size.
.PP
The ascent terminates as soon as the greatest gradient magnitude falls
below a threshold, or if upon reaching an iteration limit.
.SH OPTIONS
.TP
.B \f[B]--i\f[R] \f[I]FILE\f[R], \f[B]--i\f[R]=\f[I]FILE\f[R]
Retrieves a point set sequence (P_0, P_1, \&..., \f[I]P_i\f[R], \&...,
P_m) from \f[I]FILE\f[R].
Its absence is substituted by \f[I]stdin\f[R].
The end of a point set \f[I]P_i\f[R], which equals the line #eos, starts
the algorithm to emit the requested measure(s) applied on \f[I]P_i\f[R].
.TP
.B \f[B]--o\f[R] \f[I]FILE\f[R], \f[B]--o\f[R]=\f[I]FILE\f[R]
Redirects point set(s) to \f[I]FILE\f[R], opened in overwrite mode (not
appending mode).
Without \f[I]FILE\f[R], results are forwarded to \f[I]stdout\f[R].
Errors encountered during the program\[cq]s execution are streamed into
\f[I]stderr\f[R], and not into either \f[I]stdout\f[R] or
\f[I]FILE\f[R].
.TP
.B \f[B]--iteration-limit\f[R]=\f[I]INTEGER\f[R], \f[B]--c\f[R]=\f[I]INTEGER\f[R]
The ascent terminates as soon as reaching \f[I]INTEGER\f[R] iterations.
Boundary condition: \f[I]INTEGER\f[R] > 0.
.TP
.B \f[B]--tau\f[R]=\f[I]BINARY64\f[R], \f[B]--t\f[R]=\f[I]BINARY64\f[R]
The ascent terminates as soon as the greatest gradient magnitude falls
below \f[I]BINARY64\f[R].
Boundary condition: 0 < \f[I]BINARY64\f[R] << 1, and ideally close to
machine zero.
.TP
.B \f[B]--stepsize\f[R]=\f[I]BINARY64\f[R], \f[B]--dt\f[R]=\f[I]BINARY64\f[R]
In each iteration, the gradients are scaled with \f[I]BINARY64\f[R],
with which elements of the point set are moved.
Recommended condition: 0 < \f[I]BINARY64\f[R] < 1.
.TP
.B \f[B]--delimiter\f[R]=\f[I]CHARACTER\f[R]
A point set\[cq]s coordinates are separated by \f[I]CHARACTER\f[R],
while each point resides on a distinct line.
Recommended condition: \f[I]CHARACTER\f[R] = \[aq] \[aq],
\f[I]CHARACTER\f[R] = \[aq]\[rs]t\[aq].
.TP
.B \f[B]--no-pointset\f[R]
No point set is emitted.
This option is only useful (and valid) in combination with
\f[B]--compute-iterations\f[R].
.TP
.B \f[B]--compute-iterations\f[R]
Feed the number of actual iterations needed to the chosen output.
This number is returned before the optimised point set.
.TP
.B \f[B]--pointset-sequence\f[R]
Feed each intermediate point set, of each iteration, to the output.
This option is required to visualise the modifications made, for
instance using \f[B]pssy.py\f[R].
.TP
.B \f[B]--silent\f[R]
Suppress comments in the output stream, yielding only the computed
value.
The latter could be the point set or its cardinality.
.SH LIMITATION
.PP
The algorithm requires a two-dimensional point set sequence.
.SH AUTHORS
Benjamin Sommer.
